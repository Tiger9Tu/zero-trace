

# 开发计划

[TOC]

## 任务分解

本项目旨在利用 ebpf 技术开发一款用于跟踪内核处理流程的工具。从代码开发和功能实现的角度来看，任务可以分为以下几个模块和功能部分：



### 模块分解

我们的项目分为前端，中端和后端三个模块，如下图所示。

<img src="C:\Users\30985\AppData\Roaming\Typora\typora-user-images\image-20230815161217110.png" alt="image-20230815161217110" style="zoom:50%;" />

**模块一：ebpf 收集内核函数调用信息**

实现通用跟踪框架

- 创建一个框架，用于跟踪内核数据处理流程。
- 支持数据结构（如 bio、request、skb、page）的处理流程跟踪。

**模块二：信息分析与转化**

转化为有用的 trace 信息

- 对收集到的内核函数调用信息进行分析和处理，生成有用的跟踪信息。

**模块三：trace 信息可视化**

实现 trace 信息可视化

- 设计和开发一个界面，用于可视化处理后的 trace 信息

  



### 功能分解

**IO 基础功能**

内核数据处理流程跟踪

- 实现通用跟踪框架，用于追踪某些数据结构的处理流程，并生成延时分析报告。

存储 IO 请求全链路跟踪

- 跟踪 IO 请求在各层次的处理过程，包括进程调度和中断干扰。
- 统计各个阶段的平均耗时。
- 记录延时大于阈值的请求的详细信息及各阶段的耗时。

维度过滤器与性能统计

- 支持进程、线程、容器（cgroup）、磁盘的维度过滤。
- 统计内存和 CPU 的运行开销，保证工具的常态部署可用性和性能。

性能分析和优化

- 使用 perf 或 bpf 相关性能分析功能，分析工具运行时的 overhead。

- 优化工具的逻辑和性能，输出性能分析报告。

**扩展功能**

支持 guest 到 host 全链路跟踪

特定处理流程跟踪与延时统计

- 实现网络收发包、内存分配/回收、进程调度等处理流程的跟踪和延时统计



## 阶段计划



### 需求分析

需求分析在我们的开发流程中具有关键地位，它为我们的软件产品绘制了一张清晰的蓝图。我们的操作系统比赛项目中明确了功能需求，因此我们的需求分析实际上是对比赛要求的深入分析和理解。

通过与指导老师的讨论和交流，我们初步确定了最终实现的目标，主要包括以下几个方面：

**功能方面**

我们的主要目标是基本满足比赛要求的功能，但考虑到优先级，我们将按照顺序完成不同部分，首先是磁盘部分，然后是网络部分和 qemu 部分。

**性能方面**

我们希望我们的解决方案能够在性能方面表现出一定的优势，与同类产品相比较。我们会进行性能分析，确保我们的产品在性能上能够达到预期目标。

**用户交互**

用户将能够通过控制台执行程序，并为每个功能提供相应的参数。另外，我们还会实现可视化功能，使得输出既可以在控制台中显示，也可以在 grafana 网页前端呈现。

通过以上目标的明确界定，我们将能够确保我们的开发工作在正确的方向上前进，达到预期的功能、性能和用户体验水平。



### 系统架构设计

如前所述，我们的内核跟踪工具分为三个模块：后端、中段和前端。从系统架构的角度来看，这三个模块扮演着不同的角色。具体而言，后端负责内核处理数据的收集，中段负责整理这些数据，而前端则专注于可视化处理。更详细的信息可以在我们的系统框架设计文档中找到。



### 软件开发

系统架构设计完成后，我们的软件开发分为三个部分并行进行。在此过程中，洪瑞鹏负责后端开发，边润华负责中段开发，涂越则负责前端开发。这三个部分的软件开发任务如下：

**后端**

通过使用 ebpf 技术，我们挂载到 Linux 内核的关键函数中，以获取函数的执行信息。此部分的主要挑战在于熟悉 ebpf 框架，将 ebpf 技术应用于 Linux 内核编程。

**中端**

采用特定的数据结构，对后端提取的零散数据进行分析。我们将这些分散的数据关联到具体的处理流程中，最终生成 trace 数据结构。在这一部分，主要挑战在于数据分析，以及同步数据和异步处理流程之间的区别处理。

**前端**

我们通过一定的方法将 trace 数据上传到 Grafana 云端。由于 Grafana 支持 opentelemetry 数据，我们首先生成 opentelemetry 格式的数据，然后再通过客户端将数据传送到云端。在这一部分，主要挑战涉及网络部署，以及我们使用不常见的 API 来实现功能，因为我们直接传输 trace 数据并不是 opentelemetry 的典型应用场景。

通过这些开发任务的分工和描述，我们将能够更有效地推进项目，并充分利用各自的专长。



### 软件测试

软件测试有两个主要目标：

首先，我们测试软件的健壮性，以验证各种内核处理流程是否能够正确地生成输出。我们还会测试在吞吐量增加时，软件是否能保持稳定运行。为了实现这个目标，我们使用了 fio 工具作为 benchmark。

其次，我们还测试软件的性能，与同类产品进行比较。我们对于常态部署情况下的开销进行了详细的分析。

通过这些测试，我们将能够验证软件在各种情况下的表现，确保其健壮性和性能能够达到预期水平。



### 具体分工

| 阶段               | 洪瑞鹏                                                       | 边润华                                                       | 涂越                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| 需求分析 - 4/29    | 1.     进行需求的描述            2.     编写技术原型验证可行性 | 1.     组织队伍,报名比赛,联系指导教师            2.     任务量的评估 | 1.     完成会议报告            2.     对需求进行初步总结 |
| 系统架构设计 - 5/5 | 1.     先设计一个简单、粗暴的可行架构，完成基础功能来提交初赛 | 1.     完成对 blktrace 工具的调研与提出性能更好的可行架构设计 |                                                          |
| 软件开发 - 6/10    | 1.     编写后端eBPF程序，从内核获取数据            2.     完成中端与后端数据传输的部分 | 调研Grafana,并编写了与Grafana交互的部分接口,预留作为后期使用 | 软件自动化文档生成脚本编写                               |
| 软件测试 - 6/8     | 利用 sysbench 进行功能测试以及性能开销测试                   |                                                              | 完成软件测试，性能测试部分并可视化                       |
| 其他               | 画系统架构图                                                 | 软件安全文档编写，代码持续集成与部署文档编写                 | 完成软件的源代码文档，整理软工文档，完成展示ppt          |